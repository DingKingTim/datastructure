> [1、基本的一个二叉树](#1)
>
> [2、二叉树的基本性质](#2)
>
> [3、遍历方式](#3)



<h4 id='1'> 1、基本的一个二叉树 </h4>

![binary tree](https://github.com/DingKingTim/datastructure/blob/master/tree/media/base_binarytree.jpeg)



<h4 id='2'> 2、二叉树的基本性质 </h4>

- 第l层上的最大节点数：**`2^(l-1)`**

   ```c
   #define MAX_NODE_OF_LEVEL(l) pow(2, (l)-1)
   ```

- 高度h的树拥有的最大节点数：**`(2^h) - 1`**

  ```c
  #define MAX_NODE_OF_HIGH(h) (pow(2, h) - 1)
  ```

<h4 id='3'> 3、遍历方式 </h4>

- 深度优先遍历

   - 前序遍历: 根 --> 左 --> 右
   
   ```c
   A  B  D  E  C  F
   ```
   
   - 中序遍历: 左 --> 根 --> 右
   
   ```c
   D  B  E  A  F  C
   ```
   
   - 后序遍历: 左 --> 右 --> 根
   
   ```c
   D  E  B  F  C  A
   ```
   
- 宽度优先遍历: 

    - 左 --> 右 --下一层--> 左 --> 右
    
    ```C
    A  B  C  D  E  F
    ```
    
<h4 id='4'> 4、给定序列创建树 </h4>

单个的序列无论是前序，中序，后序，还是顺序都无法唯一确定一棵树

- 唯一确定一棵树的三种方式

   - 中序和前序组合
   
   - 中序和后序组合
   
   - 中序和顺序组合
   
 - 中序和前序组合算法：
 
   前序节点在中序中的位置idx，在前序中idx的左边节点为该节点的左节点，idx右边的节点为右节点

 
   - **`[start, end]`** 序列中顺序取出一个元素，创建节点 **`node`**
   - 查找新创建节点 **`node`** 在中序中的位置 **`idx`**
   - 以 **`idx`** 为中心，将前序分成两部分，**`idx_left`** 和 **`idx_right`**
   - **`idx_left`** 左边的元素指向新创建节点 node的左子树，其范围为 **`[start, idx-1]`**, 在此区间上重复上面步骤
   - **`idx_right`** 右边的元素指向新创建节点 node 的右子树，其范围为 **`[idx+1, end]`**，在此区间上重复上面步骤

